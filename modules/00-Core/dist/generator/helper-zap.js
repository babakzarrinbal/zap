"use strict";
/**
 *
 *    Copyright (c) 2020 Silicon Labs
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var templateUtil = require('./template-util.js');
var queryPackage = require('../db/query-package.js');
/**
 * This module contains the API for templating. For more detailed instructions, read {@tutorial template-tutorial}
 *
 * @module Templating API: toplevel utility helpers
 */
/**
 * Produces the top-of-the-file header for a C file.
 *
 * @returns The header content
 */
function zap_header() {
    return "// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.";
}
/**
 * Simple helper that produces an approved size of identation.
 *
 * @returns whitespace that is the identation.
 */
function ident(cnt) {
    if (Number.isInteger(cnt)) {
        return '  '.repeat(cnt);
    }
    else {
        return '  ';
    }
}
function new_line(cnt) {
    if (Number.isInteger(cnt)) {
        return '\n'.repeat(cnt);
    }
    else {
        return '\n';
    }
}
function backslash() {
    return '\\';
}
/**
 * Block helper that iterates over the package options of a given category.
 *
 * @param {*} category
 * @param {*} options
 */
function template_options(options) {
    var _this = this;
    return templateUtil
        .ensureTemplatePackageId(this)
        .then(function (packageId) {
        return queryPackage.selectAllOptionsValues(_this.global.db, packageId, options.hash.category);
    })
        .then(function (ens) { return templateUtil.collectBlocks(ens, options, _this); });
}
/**
 * Inside an iterator, this helper allows you to specify the content that will be output only
 * during the first element.
 *
 * @param {*} options
 * @returns content, if it's the first element inside an operator, empty otherwise.
 */
function first(options) {
    if (this.index != null && this.count != null && this.index == 0) {
        return options.fn(this);
    }
}
/**
 * Inside an iterator, this helper allows you to specify the content that will be output only
 * if the element is not the first element.
 *
 * @param {*} options
 * @returns content, if it's the first element inside an operator, empty otherwise.
 */
function not_first(options) {
    if (this.index != null && this.count != null && this.index != 0) {
        return options.fn(this);
    }
}
/**
 * Inside an iterator, this helper allows you to specify the content that will be output only
 * during the last element.
 *
 * @param {*} options
 * @returns content, if it's the last element inside an operator, empty otherwise.
 */
function last(options) {
    if (this.index != null &&
        this.count != null &&
        this.index == this.count - 1) {
        return options.fn(this);
    }
}
/**
 * Inside an iterator. the block is output only if this is NOT the last item.
 * Useful for wrapping commas in the list of arguments and such.
 *
 * @param {*} optionms
 * @returns content, if it's not the last element inside a block, empty otherwise.
 */
function not_last(options) {
    if (this.index != null &&
        this.count != null &&
        this.index != this.count - 1) {
        return options.fn(this);
    }
}
/**
 * Inside an iterator, this helper allows you to specify the content that will be output only
 * during the non-first and no-last element.
 *
 * @param {*} options
 * @returns content, if it's the middle element inside an operator, empty otherwise.
 */
function middle(options) {
    if (this.index != null &&
        this.count != null &&
        this.index != 0 &&
        this.index != this.count - 1) {
        return options.fn(this);
    }
}
/**
 * This fetches a promise which returns template options if provided
 *
 * @param {*} options
 * @param {*} key
 */
function template_option_with_code(options, key) {
    var _this = this;
    return templateUtil
        .ensureTemplatePackageId(this)
        .then(function (packageId) {
        return queryPackage.selectSpecificOptionValue(_this.global.db, packageId, options, key);
    });
}
/**
 * Forced fail halper.
 *
 * @param {*} options
 */
function fail(options) {
    var message = options.hash.message;
    if (message == null) {
        message = 'Template failure.';
    }
    throw new Error(message);
}
/**
 * This returns a boolean if the 2 strings are same
 *
 * @param {*} string_a
 * @param {*} string_b
 */
function isEqual(string_a, string_b) {
    return string_a.trim() === string_b.trim();
}
/**
 * This returns a boolean based on the 2 strings being equal or not given that both
 * @param {*} string_a
 * @param {*} string_b
 */
function is_lowercase_equal(string_a, string_b) {
    var str1 = string_a.toLowerCase().replace(/"/g, '').trim();
    var str2 = string_b.toLowerCase().replace(/"/g, '').trim();
    return 0 == str1.localeCompare(str2);
}
function toggle(condition, trueResult, falseResult) {
    return condition ? trueResult : falseResult;
}
/**
 * Remove leading and trailing spaces from a string
 *
 * @param {*} str
 * @returns A string with no leading and trailing spaces
 */
function trim_string(str) {
    if (str == null)
        return null;
    return str.trim();
}
/**
 * Split the string based on spaces and return the last word
 * @param {*} str
 */
function asLastWord(str) {
    var strings = str.trim().split(' ');
    if (strings.length > 0) {
        return strings[strings.length - 1];
    }
    return str.trim();
}
/**
 * Iteration block.
 */
function iterate(options) {
    var hash = options.hash;
    var ret = '';
    for (var i = 0; i < hash.count; i++) {
        var newContext = {
            global: this.global,
            parent: this,
            index: i,
            count: hash.count,
        };
        ret = ret.concat(options.fn(newContext));
    }
    return ret;
}
function addToAccumulator(accumulator, value) {
    if (!('accumulators' in this.global)) {
        this.global.accumulators = {};
    }
    if (!(accumulator in this.global.accumulators)) {
        this.global.accumulators[accumulator] = {
            value: [],
            sum: [],
            currentSum: 0,
        };
    }
    this.global.accumulators[accumulator].value.push(value);
    var lastSum = this.global.accumulators[accumulator].currentSum;
    var newSum;
    if (value != null) {
        newSum = lastSum + value;
    }
    else {
        newSum = lastSum;
    }
    this.global.accumulators[accumulator].sum.push(newSum);
    this.global.accumulators[accumulator].currentSum = newSum;
}
function iterateAccumulator(options) {
    var hash = options.hash;
    if (!('accumulators' in this.global)) {
        return '';
    }
    var accumulator = this.global.accumulators[hash.accumulator];
    var ret = '';
    if (accumulator != null) {
        for (var i = 0; i < accumulator.value.length; i++) {
            var newContext = {
                global: this.global,
                parent: this,
                index: i,
                count: accumulator.value.length,
                sum: accumulator.sum[i],
                value: accumulator.value[i],
            };
            ret = ret.concat(options.fn(newContext));
        }
    }
    return ret;
}
function waitForSynchronousPromise(pollInterval, promise, resolve, reject) {
    if (promise.isResolved()) {
        resolve();
    }
    else if (promise.isRejected()) {
        reject();
    }
    else {
        setTimeout(function () { return waitForSynchronousPromise(pollInterval, promise, resolve, reject); }, pollInterval);
    }
}
function promiseToResolveAllPreviousPromises(globalPromises) {
    return __awaiter(this, void 0, void 0, function () {
        var promises_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(globalPromises.length > 0)) return [3 /*break*/, 2];
                    promises_1 = [];
                    globalPromises.forEach(function (promise) {
                        promises_1.push(new Promise(function (resolve, reject) {
                            waitForSynchronousPromise(100, promise, resolve, reject);
                        }));
                    });
                    return [4 /*yield*/, Promise.all(promises_1)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    });
}
function after(options) {
    return __awaiter(this, void 0, void 0, function () {
        var newContext;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, promiseToResolveAllPreviousPromises(this.global.promises)];
                case 1:
                    _a.sent();
                    newContext = {
                        global: this.global,
                        parent: this,
                    };
                    return [2 /*return*/, options.fn(newContext)];
            }
        });
    });
}
/**
 * Given: A list of strings
 * Returns a concatenated string with spaces between each string
 */
function concatenate() {
    return Array.prototype.slice.call(arguments, 0, -1).join(' ');
}
/**
 *
 * @param numA
 * @param numB
 * @returns true if both numbers are equal else returns false
 */
function is_num_equal(numA, numB) {
    return numA == numB;
}
/**
 *
 * @param value
 * @returns true or false based on whether the value is undefined or not
 */
function is_defined(value) {
    return !(value == null || value == undefined || value == '');
}
/**
 *
 * @param mainString
 * @param replaceString
 * @param replaceWithString
 * @returns A string replaced with another string in the mainString
 */
function replace_string(mainString, replaceString, replaceWithString) {
    return mainString.replace(replaceString, replaceWithString);
}
/**
 *
 * @param str
 * @param prefixStr
 * @returns A resultant string with all string values prefixed with prefixStr
 */
function add_prefix_to_all_strings(str, prefixStr) {
    var e_1, _a, e_2, _b;
    // Remove hex values from the string
    var hexValueMatch = str.match(/[0x|x][0-9|A-F]+/g);
    var hexValues = hexValueMatch ? hexValueMatch.map(String) : [];
    var strWithoutHexValues = str;
    try {
        for (var hexValues_1 = __values(hexValues), hexValues_1_1 = hexValues_1.next(); !hexValues_1_1.done; hexValues_1_1 = hexValues_1.next()) {
            var h = hexValues_1_1.value;
            var re = new RegExp(h, 'g');
            strWithoutHexValues = strWithoutHexValues.replace(re, '');
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (hexValues_1_1 && !hexValues_1_1.done && (_a = hexValues_1.return)) _a.call(hexValues_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    //Getting unique strings
    var strs = strWithoutHexValues
        .match(/[A-Za-z]+/g)
        .map(String)
        .filter(function (v, i, a) { return a.indexOf(v) === i; });
    var res = str;
    try {
        for (var strs_1 = __values(strs), strs_1_1 = strs_1.next(); !strs_1_1.done; strs_1_1 = strs_1.next()) {
            var s = strs_1_1.value;
            // Creating an exception for  hex values and not applying this there
            if (!(s.startsWith('x') || s.startsWith('0x'))) {
                var re = new RegExp(s, 'g');
                res = res.replace(re, prefixStr + s);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (strs_1_1 && !strs_1_1.done && (_b = strs_1.return)) _b.call(strs_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return res;
}
var dep = templateUtil.deprecatedHelper;
// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
//
// Note: these exports are public API. Templates that might have been created in the past and are
// available in the wild might depend on these names.
// If you rename the functions, you need to still maintain old exports list.
exports.zap_header = zap_header;
exports.indent = ident;
exports.ident = dep(ident, { to: 'indent' });
exports.template_options = template_options;
exports.last = last;
exports.not_last = not_last;
exports.first = first;
exports.not_first = not_first;
exports.middle = middle;
exports.template_option_with_code = template_option_with_code;
exports.is_equal = isEqual;
exports.isEqual = dep(isEqual, { to: 'is_equal' });
exports.trim_string = trim_string;
exports.as_last_word = asLastWord;
exports.asLastWord = dep(asLastWord, { to: 'as_last_word' });
exports.iterate = iterate;
exports.add_to_accumulator = addToAccumulator;
exports.addToAccumulator = dep(addToAccumulator, { to: 'add_to_accumulator' });
exports.iterate_accumulator = iterateAccumulator;
exports.iterateAccumulator = dep(iterateAccumulator, {
    to: 'iterate_accumulator',
});
exports.after = after;
exports.toggle = toggle;
exports.concatenate = concatenate;
exports.is_lowercase_equal = is_lowercase_equal;
exports.new_line = new_line;
exports.backslash = backslash;
exports.is_num_equal = is_num_equal;
exports.is_defined = is_defined;
exports.fail = fail;
exports.replace_string = replace_string;
exports.add_prefix_to_all_strings = add_prefix_to_all_strings;
//# sourceMappingURL=helper-zap.js.map